

\section{Mutation testing}

In 1972 Richar Lipson introduced the mutation testing\cite{lipton1971fault} to detect fails through applying mutation operators, which is a specified change in the code. After, Acree\cite{10.5555/909622} proposed a method to evaluate the effectiveness of the testing tools using mutation operators, afterwards in 1981, Hucks\cite{Hanks80} introduced a collection of mutation operators in COBOL. Then, Morel\cite{10.5555/911352} created a few of strategies to create operator based on the inference of errors, which are difficult to observe directly. In the 80s, some authors created a set of tools, compilers and procedures to apply mutation testing\cite{10.5555/914857, Offutt1987}. From the decade of the 90 and 2000 begins the creation of some mutation testing tools for modern languages \cite{92910,170202, Maldonado2001}.

Frankl\cite{Frankl1991,Frankl1993} evaluated the effectiveness of the mutation testings considering use cases and data-flow, after introducing metrics such as covering level of the operators in the software components \cite{Offutt1996,Frankl1997,Frankl1998}. Also, Kakarlaa\cite{Kakarla2011} tested vulnerabilities in the mutation operators product of the size of the data and the programming language.

In Security testing, Mouelhi\cite{Mouelhi2007} evaluated the adaptability of the mutation operators in the testing of security policies in the three layers applications. But, this analysis is empiric and it is possible only observe changes in the user roles modules. Based on this work, some authors developed tools such as Magneto\cite{Thomas2011} an open source software to automatic evaluation of security vulnerabilities and the Upgrade evaluation tool\cite{ozdemir2019upgrade}.

Loise\cite{Loise2017} introduced 15 operators to the detection of the security fails in Java, these operators consist in modify the arguments of the functions, change the evaluation of conditional structures, vary mathematical operations and remove control structures in user authentication modules and database connections. The design of the operators uses known vulnerabilities such as injection SQL. Loise showed that these operators can reveal some kinds of vulnerabilities in some open source applications. But, there is evidence of the missing of a security evaluation criteria in open source projects. 

In recent years, the development of tools in mutation testing has been increasing, MutAPI\cite{Wen2019} generate mutation operators from common vulnerabilities in Java getting a precision of the 78\% in the detection of potential security problems. A similar tool is available for Python\cite{Zhang2020} and specific libraries\cite{Kechagia2019}. In common these tools can detect vulnerabilities, that are unexpected for the developers. However there are some limitations in mutation testing, one of them is the difference between artificial and real faults detected by mutation testing\cite{Ojdanic2023} this is because some of the vulnerabilities are not realistic because their occurrence is really low, hence it is not easy to know if they are really going to occur in a real scenario. Other limitation is the selection of the mutation strategies, because it is highly possible to have a huge set of equivalent mutants who produces a low performance of this technique of testing\cite{Pitts2023}.

Some tools include artificial intelligence techniques like deep learning\cite{Tambon2023} using probabilistic methods who allows for a more consistent decision on whether a mutant is killed or not. Other works \cite{Naeem2019, Mao2019,Tian2022} show the effectiveness of using machine learning and deep learning techniques to select mutants in order to reduce redundancy and improve test coverage.

From this preliminary revision of the state of the art, the mutation operators work only on specific cases, this is an evidence of the need to contribute with a formal framework for the generation of generic testing security mutation operators.


